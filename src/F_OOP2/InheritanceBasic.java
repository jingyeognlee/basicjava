package F_OOP2;

public class InheritanceBasic {
	public static void main(String[] args) {

		/*
		 더 잘 어울리는 것을 갖다 붙이면 된다  ex)원은 점을 포함하고 있다 - 포함
		 ex) 직사각형은 사각형이다 - 상속 낮은단계가 큰단계를 이다, 포함한다로 
		 1.상속 (is a : ~은 ~이다)
		  -기존의 클래스를 재사용하여 새로운 클래스를 작성한다.
		  -적은 양의 코드로 새로운 클래스를 작성할 수 있다.
		  -새로 작성하고자 하는 클래스의 뒤에 상속받고자 하는 클래스의 이름을
		  키워드 'extends'와 함께 써주기만하면 된다.
		  
		  class Child extends Parents{
		  
		  		. . . . 
		  }
		  -상속해주는 클래스를 '조상클래스', 상속받는 클래스를 '자손클래스'라 한다
		   :조상클래스 - 부모클래스, 상위클래스, 기반클래스
		   :자손클래스 - 자식클래스, 하위클래스, 파생클래스
		  -멤버(멤버변수,메서드)만 상속받는다.
		  -자손클래스의 멤버의 개수는 조상 클래스보다 같거나 많다.

		 2.포함 (has a : ~은 ~을 포함하고 있다)
			-상속이외의 클래스를 재사용하는 방법
			-한 클래스의 멤버변수로 다른 클래스를 선언하는 방법이다.
		
		
		3.단일상속
		 -자바에서는 단일상속(두개이상은 불가능)만 가능하다.
			class TVCR extends TV, VCR{ // 불가능
			}
		 -Tv와 VCR에 동일한 멤버가 있을 때 어떤것을 상속받을지 알 수 없다.
		  VCR의 멤버명을 바꾼다면 그동안 VCR의 멤버를 사용하던 부분들은 모두 수정해주어야한다
		 -클래스간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있다.
		
		4.Object 클래스 (모든 클래스의 조상)
		  -모든 클래스의 상속 계층도의 가장 위에 위치하는 조상클래스이다.
		  -다른 클래스로부터 상속받지 않은 클래스들은 자동적으로 object 클래스를 상속받는다.
		  
		  class Tv{
		  
		  }
		  => 컴파일후
		  class Tv extends Object{
		   Tv(){
		  	super();
		   }
		  }
		 
		  -toString()나 equlas()와 같은 메서드를 따로 정의하지않고 사용할 수 있는것은
		  Object 클래스에 정의된 것들이기 때문이다.
		  
		  
		 5.오버라이드(override)
		  -조상 클래스로부터 상속받은 메서드의 내용을 변경하는것.
		  -오버라이드 되기위한 조건 => 선언부가 일치해야한다. (메서드에만 쓸 수 있음!)
		  선언부는 똑같이 만들고 구현부만 다르게만들어야함!
		  오버라이드 호출하면 자식것이 우선이다!!!!!!!!!
		   :자손클래스에서 오버라이드하는 메서드는 조상클래스의 메서드의 명과 동일해야한다.
		   :매개변수의 타입과 and 개수가 같아야한다. ==> !(타입x || 개수x) -> (타입o && 개수o)
		   :리턴타입이 같아야한다.
		   :접근제어자를 조상 클래스보다 좁은 범위로 설정할 수 없다.
		   public인것은 public밖에 못씀!!!! ex) public String toString(){}
		   :예외는 조상클래스의 메서드보다 많이 선언할 수 없다.
		   class C extend B throws SqlException
		   
		  
		 6.super.
		  -조상클래스의 멤버와 자손클래스의 멤버가 중복정의되어 있을 때 서로 구분하기 위해 사용한다.
		  -조상멤버와 자신의 멤버를 구별하는데에 사용한다는 것을 제외하고는 this.과 근본적으로 동일
		  -static 메서드에서 사용할 수 없다. 인스턴스가 있어야만 사용가능 (class메서드에서 인스턴스 변수를 사용할 수 없는것)
		  
		 7.super() -조상클래스의 생성자를 호출할 때 사용
		  -this()와 마찬가지로 super()역시 생성자이다
		  -this() 같은 클래스의 다른 생성자를 호출할 때. super() 부모클래스의 생성자를 호출할 때 사용
		  -생성자의 첫 줄에는 조상 클래스의 생성자를 호출해야한다. this() super() 는 동시에 사용할 수 없다
		  자손클래스의 멤버가 조상클래스의 멤버를 사용할 수 있으므로 조상의 멤버들이 먼저 초기화되어야한다.
		  -호출은 자식부터 ! 왜냐하면 자식의 객체니까!
		  -생성은 부모부터 ! 왜냐하면 부모없이 자식은 나올 수 없으니까!
		  
		 8.제어자
		  -클래스, 변수 메서드의 선언부에 사용된다.
		  -접근 제어자와 그 외 제어자로 나누어진다.
		  -접근제어자 : private(내클래스안에서만), default(같은 패키지안에서만), protected, public(같은프로젝트안)
		  -그 외 제어자 : static, final, abstract,(이렇게 세개만할것) native...
		  -접근제어자와 그 외 제어자 같이 쓸 수 있다. 
		  -접근제어자를 제일 왼쪽에 많이 둔다.보통 접근제어자가 먼저오기는하는데 그 외 제어자부터와도 상관 x
		  -static(클래스의,공통적인)
		   :멤버변수, 메서드, 초기화 블럭에 사용된다.
		   :static변수
		    -> 모든인스턴스에서 공통적으로 사용한다.
		    -> 인스턴스를 생성하지 않고도 호출할 수 있다.
		    -> 클래스가 메모리에 로드될 때 생성된다.
		   :static메서드
		    -> 인스턴스를 생성하지 않고도 호출할 수 있다.
		    -> 클래스 메서드 내에서는 인스턴스 멤버를 호출할 수 없다.
		    
		  -final (마지막의, 변경할 수 없는)
		   :변수에 사용 시에는 변경할 수 없는 상수가 된다.
		   :메서드에 사용 시 오버라이드 불가!
		   :클래스에 사용 시 상속할 수 없는 클래스가 된다.
		  
		  -abstract(추상의, 미완성된)
		   :메서드와 클래스에만 사용가능
		   :메서드에 사용시 구현부는 작성하지 않는다
		    void method();
		    
		    
		 9.접근제어자
		 -private : 같은 클래스 내에서 접근가능
		 -default : 같은 패키지 내에서 접근가능 (클래스명이나 변수명 메서드명 앞에 아무것도 안쓰면 디폴트)
		 -protected 같은 패키지 내에서 + 다른 패키지의 자손클래스에서 접근 가능
		 -public 어디서든 사용할 수 있음
		 
		 -클래스에서는 default와 public만 사용가능하다(변수와 메서드에는 다 쓸수있다)
		 
		   
		10.캡슐화
		 -접근제어자를 사용하는 이유
		  :외부로부터 데이터를 보호하기위한 목적
		  :외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해 사용한다.
		  ex) 프랜차이즈 본점 
	
	
		11.다형성(polymorphism)
		 하나의 공통적인 묶음을 만들려고 씀
		 -여러가지 형태를 가질 수 있는 능력
		 -한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있다.
		 Car c = new FireCar();
		 Car c = new Ambulance();
		 -부모타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
		 
		
		12.참조변수의 형변환(상속)
		 -서로 상속관계에 있는 클래스에서만 형변환이 가능하다
		 -자손타입 -> 부모타입(업캐스팅) :형변환 생략 가능
		 -부모타입 -> 자손타입(다운캐스팅) :형변환 생략 불가
		
		
		
		13.instanceof 캐스팅이 가능한지 여부를 판단할 수 있음
		 -참조변수가 참조하고있는 인스턴스의 실제 타입을 알아보기 위해 사용
		 -연산결과가true이면 참조변수가 검사한 타입으로 형변환이 가능하다.
		 -클래스메서드와 클래스 변수는 참조변수의 타입에 영향을 받는다 (호출할 때 같은 이름이 있으면 그 타입을 찾아감...)
		 t.a를 쓰려면 다운캐스팅해야함
		 -참조변수의 타입에 영향을 받지 않는 것은 인스턴스 메서드뿐이다.
		 //부모자식관계를 정확하게 인지시켜줌
		 
		14.매개변수의 다형성
		 -참조변수의 다형적인 특징은 메서드의 매개변수에도 적용된다.
		 
		 
		15.여러객체 배열, Vector
		 -부모타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
		 -Vector
		  :배열을 사용할 경우 전체 크기를 한 번 정하면 변경할 수 없다.
		    이를 Vector 클래스를 이용하여 해결할 수 있다.
		  :동적으로 크기가 관리되는 객체배열이라고 할 수 있다.
		    
		  Vector v = new Vector();
		  Vector() : 10개의 객체를 저장할 수 있는 Vector 인스턴스를 생성한다 //하나만 저장하면 9개는 널   
		  add() : Vector에 객체를 추가한다. //차곡차곡 쌓임 add하면 1번 - 2번 - 3번 이런식으로
		  remove() : Vector에 객체를 삭제한다.
		  isEmpty() : Vector에 객체를 갖고있나, 즉 들어있나 없나 확인
		  Object get(int index) : index번째 객체를 반환한다.
		  int size() : Vector에 객체가 저장된 개수를 반환한다.
		  
		  
		16.추상클래스(abstract class)
		 -미완성된 클래스 : 미완성된 메서드를 갖고있단는 의미
		 -구성
		     abstract class 클래스명{
		    
		    }
		 -추상 메서드
		  :메서드는 선언부와 구현부로 구성된다.
		  :이 때 추상 메서드는 선언부만 작성되어 있고 구현부는 작성되지 않은 메서드를 의미한다.
		  abstract 리턴타입 리턴타입 메스드명();
		 -추상클래스로부터 상속받는 자손 클래스는 오버라이딩을 통해 조상인 클래스의 추상메서드를 구현해 주면된다.
		 
		  
		17.인터페이스(interface)
		 -일종의 추상클래스이지만 추상메서드와 상수만을 멤버로 가진다.
		 -인터페이스 작성
		  interface 인터페이스명{
		  	public static final 변수타입 변수명 = 값;
		  	public abstract 반환타입 메서드명(매개변수타입 명,...);  //(접근할 수 있는 범위 최대한 넓게해줘야해서 public 붙음)
		  } 컴파일되도 생성자 안만들어줌 (누가 도와주면 만들어줌)
		    
		  :모든 멤버변수는 public static final이어야한다. => 생략할 수 있다.
		  :모든 메서드는 public abstract이어야한다. => 생략할 수 있다.
		
		  
		 -인터페이스의 상속
		  :인터페이스는 인터페이스만 상속받을 수 있다.
		   => 구현된 메서드를 상속받으면 더이상 인터페이스가 아니게된다.
		  :인터페이스는 다중상속 가능하다 (구현이 안되어있어서 가능하다)
		  :Object와 같은 최고 조상은 없다
			 
		 -인터페이스 구현
		  :자체로는 인스턴스를 생성할 수 없다.(생성자가 없어서)
		  :자신이 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야한다.	 
		  :클래스의 확장(extends), 인터페이스의 구현(implemetns)
		  :~able 
		   => Movable (예전)
		   => IMove 인터페이스 => IMoveImpl 인터페이스한것들을 모아서 implements
		   
		 -인터페이스의 다형성
		  :인터페이스타입의 참조변수로 그를 구현한 구현체의 인스턴스를 참조할 수 있다.
		  
		 -인터페이스의 장점
		  :개발시간을 단축할 수 있다.
		  :표준화가 가능하다
		  :서로 관계가 없는 클래스들에게 관계를 맺어줄 수 있다.
		  :독립적인 프로그래밍이 가능하다
		  :7-26예제 꼭해보세요...
		  
		 -인터페이스의 이해
		  :클래스를 사용한 쪽 (user)과 클래스를 제공하는 쪽(provider)이 있다...
		  A - I - B //직접적인 관계를 간접적인 관계로
		  모듈해서 만드는 A가 제공 / B가 사용
		 
		 
		 
		18.내부클래스 (inner class)
		 -내부클래스란?
		  :클래스 내에 선언된 클래스
		  :서로 쉽게 접근할 수 있고 외부에서 볼 때 불필요한 클래스를 감춤으로
		   복잡성을 줄일 수 있다.
		   
		
		 -인스턴스클래스
		 : 외부클래스의 인스턴스 멤버들과 관련된 작업을 수행한다.
		 -스태틱클래스
		 : 외부클래스의 클래스 멤버들과 관련된 작업을 수행한다. 클래스 메서드를 관련된 작업을 수행한다.
		 -지역클래스
		 : 외부클래스의 메서드나 초기화블럭 안에 선언, 선언 영역 내에서만 사용 가능
		 -익명클래스
		 : 클래스의 선언과 객체의 생성을 동시에 진행한다
		 : 이름이 없는 클래스(일회용)
		 */
		
		
		
		
		
		
		
		
		
		
	}
}
